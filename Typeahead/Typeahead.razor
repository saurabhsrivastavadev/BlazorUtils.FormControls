@using Microsoft.Extensions.Logging
@using System.Timers;

<div class="bg-gray-100 p-4 rounded-xl">
    <input class="text-center border-2 border-gray-600 w-full rounded p-2"
           type="text"
           placeholder="@Placeholder"
           @onkeyup="HandleKeyUp"
           @onfocus="_ => _showSuggestions = true"
           @bind="CurrentValue"
           @bind:event="oninput" />

    @* Suggest values matching above text input *@
    <div class="relative">
        @if (CurrentValue.Length >= MinCharForSuggestions && _showSuggestions)
        {
            <ul class="absolute z-10 mt-1 w-full bg-white shadow-lg max-h-56
                        rounded-md py-1 text-base ring-1 ring-black ring-opacity-5
                        overflow-auto focus:outline-none sm:text-sm border-2 border-green-800"
                tabindex="-1" role="listbox"
                @onfocusin='_ => _showSuggestions = true'
                @onfocusout='_ => _showSuggestions = false'>

                @foreach (var suggestion in _matchingSuggestions)
                {
                    <li class="text-gray-900 cursor-default select-none relative py-2 pl-3 pr-9">

                        <div class="flex justify-center space-x-1 p-1 cursor-pointer"
                                @onclick="_ => {
                                    if (!_selectedValues.Contains(suggestion))
                                    {
                                        _selectedValues.Add(suggestion);
                                    }
                                    else
                                    {
                                        _selectedValues.Remove(suggestion);
                                    }
                                }">
                            <div>@suggestion</div>
                            @if (_selectedValues.Contains(suggestion))
                            {
                                <svg xmlns="http://www.w3.org/2000/svg"
                                        class="h-4 w-4 text-red-800 font-bold self-center"
                                        fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            }
                        </div>
                    </li>
                }
            </ul>
        }
        else if (Suggestions != null && Suggestions.Count > 0 && CurrentValue.Length < MinCharForSuggestions)
        {
            <div class="mt-2 font-bold">
                Enter atleast @MinCharForSuggestions characters to start search..
            </div>
        }
    </div>

    <div class="flex flex-wrap justify-center">
        @if (ShowSelectedSuggestions)
        {
            @foreach (var value in _selectedValues)
            {
                <div class="flex bg-green-100 m-2 mb-0 p-2 rounded cursor-pointer space-x-2 border-2 border-gray-500"
                 @onclick="_ => _selectedValues.Remove(value)">
                    <div>@value</div>
                    <svg xmlns="http://www.w3.org/2000/svg"
                     class="h-4 w-4 text-red-800 font-bold self-center"
                     fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </div>
            }
        }
    </div>

</div>

@code {

    [Inject]
    private ILogger<Typeahead> Logger { get; set; }

    [Parameter]
    public ISet<string> Suggestions { get; set; }

    [Parameter]
    public bool ShowSelectedSuggestions { get; set; } = true;

    [Parameter]
    public int MinCharForSuggestions { get; set; } = 2;

    [Parameter]
    public EventCallback<ISet<string>> SuggestionsChanged { get; set; }

    [Parameter]
    public bool AllowOnlySuggestedValues { get; set; } = false;

    [Parameter]
    public string Placeholder { get; set; } = string.Empty;

    [Parameter]
    public string SubmitButtonText { get; set; } = "Submit the selected values";

    [Parameter]
    public EventCallback<ISet<string>> SubmitCallback { get; set; }

    [Parameter]
    public bool ClearSelectionOnSubmit { get; set; } = true;

    private string CurrentValue { get; set; } = string.Empty;

    private string _lastValue = string.Empty;
    private ISet<string> _matchingSuggestions = new HashSet<string>();
    private Timer _debounceTimer = new Timer(400);
    private ISet<string> _selectedValues = new HashSet<string>();

    private bool _showSuggestions;

    protected override Task OnInitializedAsync()
    {
        _debounceTimer.AutoReset = false;
        _debounceTimer.Elapsed += DebounceTimerCb;

        return base.OnInitializedAsync();
    }

    protected override Task OnParametersSetAsync()
    {
        if (AllowOnlySuggestedValues && (Suggestions == null || Suggestions.Count == 0))
        {
            Logger.LogInformation("No suggestions in the typeahead component.");
        }

        return base.OnParametersSetAsync();
    }

    private void HandleKeyUp(KeyboardEventArgs args)
    {
        _debounceTimer.Stop();
        _debounceTimer.Start();

        if (args.Key == "Enter" && CurrentValue.Length >= MinCharForSuggestions && !AllowOnlySuggestedValues)
        {
            _selectedValues.Add(CurrentValue);
        }
        if (CurrentValue.Length > 1)
        {
            _showSuggestions = true;
        }
        if (args.Key == "Escape")
        {
            _showSuggestions = false;
        }
    }

    private void DebounceTimerCb(object sender, ElapsedEventArgs args)
    {
        if (CurrentValue.Length >= MinCharForSuggestions && CurrentValue != _lastValue)
        {
            _matchingSuggestions.Clear();
            _matchingSuggestions.UnionWith(Suggestions.Where(
                s => s.Contains(CurrentValue, StringComparison.OrdinalIgnoreCase)));
            StateHasChanged();
        }
        else if (CurrentValue != _lastValue)
        {
            _matchingSuggestions.Clear();
            StateHasChanged();
        }

        _lastValue = CurrentValue;
    }

    private void SubmitSelectedValues()
    {
        SubmitCallback.InvokeAsync(_selectedValues);

        if (ClearSelectionOnSubmit)
        {
            _selectedValues.Clear();
            CurrentValue = string.Empty;
        }
    }
}